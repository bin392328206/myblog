(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{177:function(e,t,n){"use strict";n.r(t);var a=n(0),r=Object(a.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"content"},[n("h1",{attrs:{id:"自己学习k8s采坑"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#自己学习k8s采坑","aria-hidden":"true"}},[e._v("#")]),e._v(" 自己学习K8s采坑")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://www.funtl.com/assets1/clipart1469859.png",alt:"Docker和K8s"}})]),e._v(" "),n("h2",{attrs:{id:"什么是k8s"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#什么是k8s","aria-hidden":"true"}},[e._v("#")]),e._v(" 什么是K8s")]),e._v(" "),n("pre",[n("code",[e._v("Kubernetes 是容器集群管理系统，是一个开源的平台，可以实现容器集群的自动化部署、\n自动扩缩容、维护等功能。使用 Kubernetes 我们可以：\n1.快速部署应用\n2.快速扩展应用\n3.无缝对接新的应用功能\n4.节省资源，优化硬件资源的使用\n")])]),e._v(" "),n("h2",{attrs:{id:"特点"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#特点","aria-hidden":"true"}},[e._v("#")]),e._v(" 特点")]),e._v(" "),n("pre",[n("code",[e._v("可移植： 支持公有云，私有云，混合云，多重云（多个公共云）\n可扩展： 模块化，插件化，可挂载，可组合\n自动化： 自动部署，自动重启，自动复制，自动伸缩/扩展\n")])]),e._v(" "),n("h2",{attrs:{id:"为什么需要-kubernetes"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要-kubernetes","aria-hidden":"true"}},[e._v("#")]),e._v(" 为什么需要 Kubernetes")]),e._v(" "),n("pre",[n("code",[e._v("多个进程协同工作\n存储系统挂载\n应用健康检查\n应用实例的复制\n自动伸缩/扩展\n注册与发现\n负载均衡\n滚动更新\n资源监控\n日志访问\n调试应用程序\n提供认证和授权\n")])]),e._v(" "),n("h1",{attrs:{id:"kubernetes-安装前的准备"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#kubernetes-安装前的准备","aria-hidden":"true"}},[e._v("#")]),e._v(" Kubernetes 安装前的准备")]),e._v(" "),n("pre",[n("code",[e._v("本次安装采用 Ubuntu Server X64 18.04 LTS 版本安装 kubernetes 集群环境，集群节点为 1 主 2 从模式，\nOS：Ubuntu Server X64 18.04 LTS（16.04 版本步骤相同，再之前则不同）\nCPU：最低要求，1 CPU 2 核\n内存：最低要求，2GB\n磁盘：最低要求，20GB\nUbuntu Server 18.04 X64 Kubernetes Master\nUbuntu Server 18.04 X64 Kubernetes Slave1\nUbuntu Server 18.04 X64 Kubernetes Slave2\n关闭交换空间：sudo swapoff -a\n避免开机启动交换空间：注释 /etc/fstab 中的 swap\n关闭防火墙：ufw disable\n")])]),e._v(" "),n("h1",{attrs:{id:"使用-apt-安装-docker"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#使用-apt-安装-docker","aria-hidden":"true"}},[e._v("#")]),e._v(" 使用 APT 安装 Docker")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('# 更新软件源\nsudo apt-get update\n# 安装所需依赖\nsudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common\n# 安装 GPG 证书\ncurl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -\n# 新增软件源信息\nsudo add-apt-repository "deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable"\n# 再次更新软件源\nsudo apt-get -y update\n# 安装 Docker CE 版\nsudo apt-get -y install docker-ce\n')])])]),n("h1",{attrs:{id:"配置加速器"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#配置加速器","aria-hidden":"true"}},[e._v("#")]),e._v(" 配置加速器")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('{\n  "registry-mirrors": [\n    "https://registry.docker-cn.com"\n  ]\n}\n')])])]),n("h1",{attrs:{id:"修改主机名"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#修改主机名","aria-hidden":"true"}},[e._v("#")]),e._v(" 修改主机名")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("# 查看当前主机名\nhostnamectl\n# 显示如下内容\n   Static hostname: ubuntu\n         Icon name: computer-vm\n           Chassis: vm\n        Machine ID: 33011e0a95094672b99a198eff07f652\n           Boot ID: dc856039f0d24164a9f8a50c506be96d\n    Virtualization: vmware\n  Operating System: Ubuntu 18.04.2 LTS\n            Kernel: Linux 4.15.0-48-generic\n      Architecture: x86-64\n")])])]),n("h1",{attrs:{id:"安装-kubeadm"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#安装-kubeadm","aria-hidden":"true"}},[e._v("#")]),e._v(" 安装 kubeadm")]),e._v(" "),n("pre",[n("code",[e._v("kubeadm 是 kubernetes 的集群安装工具，能够快速安装 kubernetes 集群。\n")])]),e._v(" "),n("h1",{attrs:{id:"配置软件源"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#配置软件源","aria-hidden":"true"}},[e._v("#")]),e._v(" 配置软件源")]),e._v(" "),n("pre",[n("code",[e._v("# 安装系统工具\napt-get update && apt-get install -y apt-transport-https\n# 安装 GPG 证书\ncurl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add -\n# 写入软件源；注意：我们用系统代号为 bionic，但目前阿里云不支持，所以沿用 16.04 的 xenial\ncat << EOF >/etc/apt/sources.list.d/kubernetes.list\n> deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main\n> EOF\n")])]),e._v(" "),n("h1",{attrs:{id:"安装-kubeadm，kubelet，kubectl"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#安装-kubeadm，kubelet，kubectl","aria-hidden":"true"}},[e._v("#")]),e._v(" 安装 kubeadm，kubelet，kubectl")]),e._v(" "),n("pre",[n("code",[e._v("# 安装\napt-get update  \napt-get install -y kubelet kubeadm kubectl\n\n# 安装过程如下，注意 kubeadm 的版本号\nReading package lists... Done\nBuilding dependency tree       \nReading state information... Done\nThe following additional packages will be installed:\n  conntrack cri-tools kubernetes-cni socat\nThe following NEW packages will be installed:\n  conntrack cri-tools kubeadm kubectl kubelet kubernetes-cni socat\n0 upgraded, 7 newly installed, 0 to remove and 96 not upgraded.\nNeed to get 50.6 MB of archives.\nAfter this operation, 290 MB of additional disk space will be used.\nGet:1 http://mirrors.aliyun.com/ubuntu bionic/main amd64 conntrack amd64 1:1.4.4+snapshot20161117-6ubuntu2 [30.6 kB]\nGet:2 http://mirrors.aliyun.com/ubuntu bionic/main amd64 socat amd64 1.7.3.2-2ubuntu2 [342 kB]\nGet:3 https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial/main amd64 cri-tools amd64 1.12.0-00 [5,343 kB]\nGet:4 https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial/main amd64 kubernetes-cni amd64 0.7.5-00 [6,473 kB]\nGet:5 https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial/main amd64 kubelet amd64 1.14.1-00 [21.5 MB]\nGet:6 https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial/main amd64 kubectl amd64 1.14.1-00 [8,806 kB]\nGet:7 https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial/main amd64 kubeadm amd64 1.14.1-00 [8,150 kB]\nFetched 50.6 MB in 5s (9,912 kB/s) \nSelecting previously unselected package conntrack.\n(Reading database ... 67205 files and directories currently installed.)\nPreparing to unpack .../0-conntrack_1%3a1.4.4+snapshot20161117-6ubuntu2_amd64.deb ...\nUnpacking conntrack (1:1.4.4+snapshot20161117-6ubuntu2) ...\nSelecting previously unselected package cri-tools.\nPreparing to unpack .../1-cri-tools_1.12.0-00_amd64.deb ...\nUnpacking cri-tools (1.12.0-00) ...\nSelecting previously unselected package kubernetes-cni.\nPreparing to unpack .../2-kubernetes-cni_0.7.5-00_amd64.deb ...\nUnpacking kubernetes-cni (0.7.5-00) ...\nSelecting previously unselected package socat.\nPreparing to unpack .../3-socat_1.7.3.2-2ubuntu2_amd64.deb ...\nUnpacking socat (1.7.3.2-2ubuntu2) ...\nSelecting previously unselected package kubelet.\nPreparing to unpack .../4-kubelet_1.14.1-00_amd64.deb ...\nUnpacking kubelet (1.14.1-00) ...\nSelecting previously unselected package kubectl.\nPreparing to unpack .../5-kubectl_1.14.1-00_amd64.deb ...\nUnpacking kubectl (1.14.1-00) ...\nSelecting previously unselected package kubeadm.\nPreparing to unpack .../6-kubeadm_1.14.1-00_amd64.deb ...\nUnpacking kubeadm (1.14.1-00) ...\nSetting up conntrack (1:1.4.4+snapshot20161117-6ubuntu2) ...\nSetting up kubernetes-cni (0.7.5-00) ...\nSetting up cri-tools (1.12.0-00) ...\nSetting up socat (1.7.3.2-2ubuntu2) ...\nSetting up kubelet (1.14.1-00) ...\nCreated symlink /etc/systemd/system/multi-user.target.wants/kubelet.service → /lib/systemd/system/kubelet.service.\nSetting up kubectl (1.14.1-00) ...\nProcessing triggers for man-db (2.8.3-2ubuntu0.1) ...\n# 注意这里的版本号，我们使用的是 kubernetes v1.14.1\nSetting up kubeadm (1.14.1-00) ...\n\n# 设置 kubelet 自启动，并启动 kubelet\nsystemctl enable kubelet && systemctl start kubelet\n")])]),e._v(" "),n("h1",{attrs:{id:"配置-kubeadm"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#配置-kubeadm","aria-hidden":"true"}},[e._v("#")]),e._v(" 配置 kubeadm")]),e._v(" "),n("pre",[n("code",[e._v("安装 kubernetes 主要是安装它的各个镜像，而 kubeadm 已经为我们集成好了运行 kubernetes 所需的基本镜像。但由于国内的网络原因，在搭建环境时，无法拉取到这些镜像。此时我们只需要修改为阿里云提供的镜像服务即可解决该问题。\n")])]),e._v(" "),n("h1",{attrs:{id:"创建并修改配置"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#创建并修改配置","aria-hidden":"true"}},[e._v("#")]),e._v(" 创建并修改配置")]),e._v(" "),n("pre",[n("code",[e._v('# 导出配置文件\nkubeadm config print init-defaults --kubeconfig ClusterConfiguration > kubeadm.yml\n# 修改配置为如下内容\napiVersion: kubeadm.k8s.io/v1beta1\nbootstrapTokens:\n- groups:\n  - system:bootstrappers:kubeadm:default-node-token\n  token: abcdef.0123456789abcdef\n  ttl: 24h0m0s\n  usages:\n  - signing\n  - authentication\nkind: InitConfiguration\nlocalAPIEndpoint:\n  # 修改为主节点 IP\n  advertiseAddress: 192.168.141.130\n  bindPort: 6443\nnodeRegistration:\n  criSocket: /var/run/dockershim.sock\n  name: kubernetes-master\n  taints:\n  - effect: NoSchedule\n    key: node-role.kubernetes.io/master\n---\napiServer:\n  timeoutForControlPlane: 4m0s\napiVersion: kubeadm.k8s.io/v1beta1\ncertificatesDir: /etc/kubernetes/pki\nclusterName: kubernetes\ncontrolPlaneEndpoint: ""\ncontrollerManager: {}\ndns:\n  type: CoreDNS\netcd:\n  local:\n    dataDir: /var/lib/etcd\n# 国内不能访问 Google，修改为阿里云\nimageRepository: registry.aliyuncs.com/google_containers\nkind: ClusterConfiguration\n# 修改版本号\nkubernetesVersion: v1.14.1\nnetworking:\n  dnsDomain: cluster.local\n  # 配置成 Calico 的默认网段\n  podSubnet: "192.168.0.0/16"\n  serviceSubnet: 10.96.0.0/12\nscheduler: {}\n---\n# 开启 IPVS 模式\napiVersion: kubeproxy.config.k8s.io/v1alpha1\nkind: KubeProxyConfiguration\nfeatureGates:\n  SupportIPVSProxyMode: true\nmode: ipvs\n')])]),e._v(" "),n("h1",{attrs:{id:"安装-kubernetes-主节点"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#安装-kubernetes-主节点","aria-hidden":"true"}},[e._v("#")]),e._v(" 安装 kubernetes 主节点")]),e._v(" "),n("pre",[n("code",[e._v('执行以下命令初始化主节点，该命令指定了初始化时需要使用的配置文件，其中添加 --experimental-upload-certs 参数可以在后续执行加入节点时自动分发证书文件。追加的 tee kubeadm-init.log 用以输出日志。\nkubeadm init --config=kubeadm.yml --experimental-upload-certs | tee kubeadm-init.log\n\n# 安装成功则会有如下输出\n[init] Using Kubernetes version: v1.14.1\n[preflight] Running pre-flight checks\n        [WARNING IsDockerSystemdCheck]: detected "cgroupfs" as the Docker cgroup driver. The recommended driver is "systemd". Please follow the guide at https://kubernetes.io/docs/setup/cri/\n[preflight] Pulling images required for setting up a Kubernetes cluster\n[preflight] This might take a minute or two, depending on the speed of your internet connection\n[preflight] You can also perform this action in beforehand using \'kubeadm config images pull\'\n[kubelet-start] Writing kubelet environment file with flags to file "/var/lib/kubelet/kubeadm-flags.env"\n[kubelet-start] Writing kubelet configuration to file "/var/lib/kubelet/config.yaml"\n[kubelet-start] Activating the kubelet service\n[certs] Using certificateDir folder "/etc/kubernetes/pki"\n[certs] Generating "ca" certificate and key\n[certs] Generating "apiserver" certificate and key\n[certs] apiserver serving cert is signed for DNS names [kubernetes-master kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.96.0.1 192.168.141.130]\n[certs] Generating "apiserver-kubelet-client" certificate and key\n[certs] Generating "front-proxy-ca" certificate and key\n[certs] Generating "front-proxy-client" certificate and key\n[certs] Generating "etcd/ca" certificate and key\n[certs] Generating "etcd/peer" certificate and key\n[certs] etcd/peer serving cert is signed for DNS names [kubernetes-master localhost] and IPs [192.168.141.130 127.0.0.1 ::1]\n[certs] Generating "etcd/server" certificate and key\n[certs] etcd/server serving cert is signed for DNS names [kubernetes-master localhost] and IPs [192.168.141.130 127.0.0.1 ::1]\n[certs] Generating "etcd/healthcheck-client" certificate and key\n[certs] Generating "apiserver-etcd-client" certificate and key\n[certs] Generating "sa" key and public key\n[kubeconfig] Using kubeconfig folder "/etc/kubernetes"\n[kubeconfig] Writing "admin.conf" kubeconfig file\n[kubeconfig] Writing "kubelet.conf" kubeconfig file\n[kubeconfig] Writing "controller-manager.conf" kubeconfig file\n[kubeconfig] Writing "scheduler.conf" kubeconfig file\n[control-plane] Using manifest folder "/etc/kubernetes/manifests"\n[control-plane] Creating static Pod manifest for "kube-apiserver"\n[control-plane] Creating static Pod manifest for "kube-controller-manager"\n[control-plane] Creating static Pod manifest for "kube-scheduler"\n[etcd] Creating static Pod manifest for local etcd in "/etc/kubernetes/manifests"\n[wait-control-plane] Waiting for the kubelet to boot up the control plane as static Pods from directory "/etc/kubernetes/manifests". This can take up to 4m0s\n[apiclient] All control plane components are healthy after 20.003326 seconds\n[upload-config] storing the configuration used in ConfigMap "kubeadm-config" in the "kube-system" Namespace\n[kubelet] Creating a ConfigMap "kubelet-config-1.14" in namespace kube-system with the configuration for the kubelets in the cluster\n[upload-certs] Storing the certificates in ConfigMap "kubeadm-certs" in the "kube-system" Namespace\n[upload-certs] Using certificate key:\n2cd5b86c4905c54d68cc7dfecc2bf87195e9d5d90b4fff9832d9b22fc5e73f96\n[mark-control-plane] Marking the node kubernetes-master as control-plane by adding the label "node-role.kubernetes.io/master=\'\'"\n[mark-control-plane] Marking the node kubernetes-master as control-plane by adding the taints [node-role.kubernetes.io/master:NoSchedule]\n[bootstrap-token] Using token: abcdef.0123456789abcdef\n[bootstrap-token] Configuring bootstrap tokens, cluster-info ConfigMap, RBAC Roles\n[bootstrap-token] configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials\n[bootstrap-token] configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token\n[bootstrap-token] configured RBAC rules to allow certificate rotation for all node client certificates in the cluster\n[bootstrap-token] creating the "cluster-info" ConfigMap in the "kube-public" namespace\n[addons] Applied essential addon: CoreDNS\n[addons] Applied essential addon: kube-proxy\n\nYour Kubernetes control-plane has initialized successfully!\n\nTo start using your cluster, you need to run the following as a regular user:\n\n  mkdir -p $HOME/.kube\n  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config\n  sudo chown $(id -u):$(id -g) $HOME/.kube/config\n\nYou should now deploy a pod network to the cluster.\nRun "kubectl apply -f [podnetwork].yaml" with one of the options listed at:\n  https://kubernetes.io/docs/concepts/cluster-administration/addons/\n\nThen you can join any number of worker nodes by running the following on each as root:\n\n# 后面子节点加入需要如下命令\nkubeadm join 192.168.141.130:6443 --token abcdef.0123456789abcdef \\\n    --discovery-token-ca-cert-hash sha256:cab7c86212535adde6b8d1c7415e81847715cfc8629bb1d270b601744d662515\n')])]),e._v(" "),n("h1",{attrs:{id:"配置-kubectl"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#配置-kubectl","aria-hidden":"true"}},[e._v("#")]),e._v(" 配置 kubectl")]),e._v(" "),n("pre",[n("code",[e._v("mkdir -p $HOME/.kube\ncp -i /etc/kubernetes/admin.conf $HOME/.kube/config\n\n# 非 ROOT 用户执行\nchown $(id -u):$(id -g) $HOME/.kube/config\n")])]),e._v(" "),n("h1",{attrs:{id:"验证是否成功"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#验证是否成功","aria-hidden":"true"}},[e._v("#")]),e._v(" 验证是否成功")]),e._v(" "),n("pre",[n("code",[e._v("kubectl get node\n\n# 能够打印出节点信息即表示成功\nNAME                STATUS     ROLES    AGE     VERSION\nkubernetes-master   NotReady   master   8m40s   v1.14.1\n")])]),e._v(" "),n("h1",{attrs:{id:"kubeadm-init-的执行过程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#kubeadm-init-的执行过程","aria-hidden":"true"}},[e._v("#")]),e._v(" kubeadm init 的执行过程")]),e._v(" "),n("pre",[n("code",[e._v("init：指定版本进行初始化操作\npreflight：初始化前的检查和下载所需要的 Docker 镜像文件\nkubelet-start：生成 kubelet 的配置文件 var/lib/kubelet/config.yaml，没有这个文件 kubelet 无法启动，所以初始化之前的 kubelet 实际上启动不会成功\ncertificates：生成 Kubernetes 使用的证书，存放在 /etc/kubernetes/pki 目录中\nkubeconfig：生成 KubeConfig 文件，存放在 /etc/kubernetes 目录中，组件之间通信需要使用对应文件\ncontrol-plane：使用 /etc/kubernetes/manifest 目录下的 YAML 文件，安装 Master 组件\netcd：使用 /etc/kubernetes/manifest/etcd.yaml 安装 Etcd 服务\nwait-control-plane：等待 control-plan 部署的 Master 组件启动\napiclient：检查 Master 组件服务状态。\nuploadconfig：更新配置\nkubelet：使用 configMap 配置 kubelet\npatchnode：更新 CNI 信息到 Node 上，通过注释的方式记录\nmark-control-plane：为当前节点打标签，打了角色 Master，和不可调度标签，这样默认就不会使用 Master 节点来运行 Pod\nbootstrap-token：生成 token 记录下来，后边使用 kubeadm join 往集群中添加节点时会用到\naddons：安装附加组件 CoreDNS 和 kube-proxy\n")])]),e._v(" "),n("h1",{attrs:{id:"使用-kubeadm-配置-slave-节点"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#使用-kubeadm-配置-slave-节点","aria-hidden":"true"}},[e._v("#")]),e._v(" 使用 kubeadm 配置 slave 节点")]),e._v(" "),n("p",[e._v("将 slave 节点加入到集群中很简单，只需要在 slave 服务器上安装 kubeadm，kubectl，kubelet 三个工具，然后使用 kubeadm join 命令加入即可。准备工作如下：\n修改主机名\n配置软件源\n安装三个工具\n由于之前章节已经说明了操作步骤，此处不再赘述。")]),e._v(" "),n("h1",{attrs:{id:"将-slave-加入到集群"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#将-slave-加入到集群","aria-hidden":"true"}},[e._v("#")]),e._v(" 将 slave 加入到集群")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('kubeadm join 192.168.141.130:6443 --token abcdef.0123456789abcdef --discovery-token-ca-cert-hash sha256:cab7c86212535adde6b8d1c7415e81847715cfc8629bb1d270b601744d662515\n\n# 安装成功将看到如下信息\n[preflight] Running pre-flight checks\n        [WARNING IsDockerSystemdCheck]: detected "cgroupfs" as the Docker cgroup driver. The recommended driver is "systemd". Please follow the guide at https://kubernetes.io/docs/setup/cri/\n[preflight] Reading configuration from the cluster...\n[preflight] FYI: You can look at this config file with \'kubectl -n kube-system get cm kubeadm-config -oyaml\'\n[kubelet-start] Downloading configuration for the kubelet from the "kubelet-config-1.14" ConfigMap in the kube-system namespace\n[kubelet-start] Writing kubelet configuration to file "/var/lib/kubelet/config.yaml"\n[kubelet-start] Writing kubelet environment file with flags to file "/var/lib/kubelet/kubeadm-flags.env"\n[kubelet-start] Activating the kubelet service\n[kubelet-start] Waiting for the kubelet to perform the TLS Bootstrap...\n\nThis node has joined the cluster:\n* Certificate signing request was sent to apiserver and a response was received.\n* The Kubelet was informed of the new secure connection details.\n\nRun \'kubectl get nodes\' on the control-plane to see this node join the cluster.\n\n')])])]),n("pre",[n("code",[e._v("说明：\n\ntoken\n可以通过安装 master 时的日志查看 token 信息\n可以通过 kubeadm token list 命令打印出 token 信息\n如果 token 过期，可以使用 kubeadm token create 命令创建新的 token\ndiscovery-token-ca-cert-hash\n可以通过安装 master 时的日志查看 sha256 信息\n可以通过 openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2>/dev/null | openssl dgst -sha256 -hex | sed 's/^.* //' 命令查看 sha256 信息\n")])]),e._v(" "),n("h1",{attrs:{id:"验证是否成功-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#验证是否成功-2","aria-hidden":"true"}},[e._v("#")]),e._v(" 验证是否成功")]),e._v(" "),n("pre",[n("code",[e._v("回到 master 服务器\nkubectl get nodes\n\n# 可以看到 slave 成功加入 master\nNAME                STATUS     ROLES    AGE   VERSION\nkubernetes-master   NotReady   master   9h    v1.14.1\nkubernetes-slave1   NotReady   <none>   22s   v1.14.1\n")])])])}],!1,null,null,null);t.default=r.exports}}]);