(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{202:function(t,a,e){"use strict";e.r(a);var i=e(0),v=Object(i.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("div",{staticClass:"content"},[e("h1",{attrs:{id:"实战java高并发编程有感"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实战java高并发编程有感","aria-hidden":"true"}},[t._v("#")]),t._v(" 实战Java高并发编程有感")]),t._v(" "),e("p",[t._v("##并发对于服务端编程 确实是有不错的作用")]),t._v(" "),e("h2",{attrs:{id:"几个并发的重要概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#几个并发的重要概念","aria-hidden":"true"}},[t._v("#")]),t._v(" 几个并发的重要概念")]),t._v(" "),e("ul",[e("li",[t._v("同步和异步（同步等一个任务完成后等返回结果后才完成下一个任务 异步就好像是只要你发出了这个任务 你就已经完成任务了 ）")]),t._v(" "),e("li",[t._v("并发和并行 并发 表示 多个任务交替进行 其实在同一时刻 也只有一个再执行 并行 才是真的同时进行")]),t._v(" "),e("li",[t._v("临界资源 就是再并发环境下 只能有一个线程能获得他的资源 这种资源就是临界资源")]),t._v(" "),e("li",[t._v("阻塞和非阻塞")]),t._v(" "),e("li",[t._v("原子性 是指一个操作是不可中断的，即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰（Long 类型的 数据类型是不具备原子性的）")]),t._v(" "),e("li",[t._v("可见性 是指一个线程修改了一个共享变量的值，其他线程能够立即知道这个修改，对于串行来说 这个问题是不存在的 因为一个步骤执行后 你下次再去获取这个资源的时候你拿到的数据肯定是最新的")]),t._v(" "),e("li",[t._v("有序性 对于一个线程的执行而言 我们总是以为代码的执行从先往后，依次执行 但是这只是对于一个线程而言是这样的 ，但是在并发的条件下 他有可能进行指令重排")])])])}],!1,null,null,null);a.default=v.exports}}]);