(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{216:function(t,e,l){"use strict";l.r(e);var i=l(0),a=Object(i.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,e=t.$createElement,l=t._self._c||e;return l("div",{staticClass:"content"},[l("h3",{attrs:{id:""}},[l("a",{staticClass:"header-anchor",attrs:{href:"#","aria-hidden":"true"}},[t._v("#")])]),t._v(" "),l("blockquote",[l("p",[t._v("File")])]),t._v(" "),l("blockquote",[l("p",[t._v("递归")])]),t._v(" "),l("h2",{attrs:{id:"file"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#file","aria-hidden":"true"}},[t._v("#")]),t._v(" File")]),t._v(" "),l("h3",{attrs:{id:"io概述"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#io概述","aria-hidden":"true"}},[t._v("#")]),t._v(" IO概述")]),t._v(" "),l("blockquote",[l("p",[t._v("回想之前写过的程序，数据都是在内存中，一旦程序运行结束，这些数据都没有了，等下次再想使用这些数据，可是已经没有了。那怎么办呢？能不能把运算完的数据都保存下来，下次程序启动的时候，再把这些数据读出来继续使用呢？其实要把数据持久化存储，就需要把内存中的数据存储到内存以外的其他持久化设备(硬盘、光盘、U盘等)上")])]),t._v(" "),l("pre",[l("code",[t._v("* 当需要把内存中的数据存储到持久化设备上这个动作称为输出（写）Output操作\n* 当把持久设备上的数据读取到内存中的这个动作称为输入（读）Input操作\n* 因此我们把这种输入和输出动作称为IO操作\n")])]),t._v(" "),l("blockquote",[l("p",[t._v("简单了解IO是怎么一回事之后，接下来就要进一步做系统了解\n* 在我们操作系统中，数据都保存在文件中，而文件存放相应的文件夹中。那么Java中是如何描述这些的呢")])]),t._v(" "),l("hr"),t._v(" "),l("h3",{attrs:{id:"file类"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#file类","aria-hidden":"true"}},[t._v("#")]),t._v(" File类")]),t._v(" "),l("blockquote",[l("p",[t._v("打开API，搜索File类。阅读其描述：File文件和目录路径名的抽象表示形式。即，Java中把文件或者目录（文件夹）都封装成File对象。也就是说如果我们要去操作硬盘上的文件，或者文件夹只要找到File这个类即可。那么我们就要研究研究File这个类中都有那些功能可以操作文件或者文件夹呢")])]),t._v(" "),l("hr"),t._v(" "),l("h4",{attrs:{id:"file类的构造函数"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#file类的构造函数","aria-hidden":"true"}},[t._v("#")]),t._v(" File类的构造函数")]),t._v(" "),l("p",[l("img",{attrs:{src:"https://note.youdao.com/yws/public/resource/50a41f16bd4964e87185615287e32c81/xmlnote/9A93EDE1A91A4AFEA98A9221FFCB95D0/31843",alt:"image"}})]),t._v(" "),l("ul",[l("li",[t._v("通过构造方法创建File对象，我们进行演示")])]),t._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[t._v('    public class FileDemo {\n    \tpublic static void main(String[] args) {\n    \t\t//File构造函数演示\n    \t\tString pathName = "e:\\\\test\\\\Hello.java";\n    \t\tFile f1 = new File(pathName);//将Test22文件封装成File对象。注意；有可以封装不存在文件或者文件夹，变成对象。\n    \t\tSystem.out.println(f1);\n    \t\t\n    \t\tFile f2 = new File("e:\\\\test","Hello.java");\n    \t\tSystem.out.println(f2);\n    \t\t\n    \t\t//将parent封装成file对象。\n    \t\tFile dir = new File("e:\\\\test");\n    \t\tFile f3 = new File(dir,"Hello.java");\n    \t\tSystem.out.println(f3);\n    \t}\n    }\n\n')])])]),l("hr"),t._v(" "),l("h4",{attrs:{id:"file类的获取"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#file类的获取","aria-hidden":"true"}},[t._v("#")]),t._v(" File类的获取")]),t._v(" "),l("blockquote",[l("p",[t._v("创建完了File对象之后，那么File类中都有如下常用方法，可以获取文件相关信息")])]),t._v(" "),l("p",[l("img",{attrs:{src:"https://note.youdao.com/yws/public/resource/50a41f16bd4964e87185615287e32c81/xmlnote/2AE04BEEA791472EAF762A6E679FDC4B/31845",alt:"image"}})]),t._v(" "),l("ul",[l("li",[t._v("方法演示如下")])]),t._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[t._v('    public class FileMethodDemo {\n    \tpublic static void main(String[] args) {\n    \t\t//创建文件对象\n    \t\tFile file = new File("Test22.java");\n    \t\t//获取文件的绝对路径，即全路径\n    \t\tString absPath = file.getAbsolutePath();\n    \t\t//File中封装的路径是什么获取到的就是什么。\n    \t\tString path = file.getPath();\n    \t\t//获取文件名称\n    \t\tString filename = file.getName();\n    \t\t//获取文件大小\n    \t\tlong size = file.length();\n    \t\t\n    \t\tSystem.out.println("absPath="+absPath);\n    \t\tSystem.out.println("path="+path);\n    \t\tSystem.out.println("filename="+filename);\n    \t\tSystem.out.println("size="+size);\n    \t}\n    }\n\n')])])]),l("hr"),t._v(" "),l("h4",{attrs:{id:"文件和文件夹的创建与删除等"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#文件和文件夹的创建与删除等","aria-hidden":"true"}},[t._v("#")]),t._v(" 文件和文件夹的创建与删除等")]),t._v(" "),l("blockquote",[l("p",[t._v("经常上面介绍，我们知道可以通过File获取到文件名称，文件路径(目录)等信息。\n接下来演示使用File类创建、删除文件等操作")])]),t._v(" "),l("p",[l("img",{attrs:{src:"https://note.youdao.com/yws/public/resource/50a41f16bd4964e87185615287e32c81/xmlnote/E3E5FCBAB6A04EBBB4378192000051A2/31847",alt:"image"}})]),t._v(" "),l("ul",[l("li",[t._v("我们进行方法演示")])]),t._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[t._v('    public class FileMethodDemo2 {\n    \tpublic static void main(String[] args) throws IOException {\n    \t\t// 对文件或者文件加进行操作。\n    \t\tFile file = new File("e:\\\\file.txt");\n    \t\t// 创建文件，如果文件不存在，创建 true 。 如果文件存在，则不创建 false。 如果路径错误，IOException。\n    \t\tboolean b1 = file.createNewFile();\n    \t\tSystem.out.println("b1=" + b1);\n    \t\t//-----------删除文件操作-------注意：不去回收站。慎用------\n    \t\t boolean b2 = file.delete();\n    \t\t System.out.println("b2="+b2);\n    \n    \t\t//-----------需要判断文件是否存在------------\n    \t\t boolean b3 = file.exists();\n    \t\t System.out.println("b3="+b3);\n    \n    \t\t//-----------对目录操作 创建，删除，判断------------\n    \t\tFile dir = new File("e:\\\\abc");\n    \t\t//mkdir()创建单个目录。//dir.mkdirs();创建多级目录\n    \t\tboolean b4 = dir.mkdir();\n    \t\tSystem.out.println("b4="+b4);\n    \t\t//删除目录时，如果目录中有内容，无法直接删除。\n    \t\tboolean b5 = dir.delete();\n    \t\t//只有将目录中的内容都删除后，保证该目录为空。这时这个目录才可以删除。\n    \t\tSystem.out.println("b5=" + b5);\n    \n    \t\t//-----------判断文件，目录------------\n    \t\tFile f = new File("e:\\\\javahaha");// 要判断是否是文件还是目录，必须先判断存在。\n    \t\t// f.mkdir();//f.createNewFile();\n    \t\tSystem.out.println(f.isFile());\n    \t\tSystem.out.println(f.isDirectory());\n    \t}\n    }\n\n')])])]),l("hr"),t._v(" "),l("h4",{attrs:{id:"listfile-方法"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#listfile-方法","aria-hidden":"true"}},[t._v("#")]),t._v(" listFile()方法")]),t._v(" "),l("blockquote",[l("p",[t._v("文件都存放在目录（文件夹）中，那么如何获取一个目录中的所有文件或者目录中的文件夹呢？那么我们先想想，一个目录中可能有多个文件或者文件夹，那么如果File中有功能获取到一个目录中的所有文件和文件夹，那么功能得到的结果要么是数组，要么是集合。我们开始查阅API")])]),t._v(" "),l("p",[l("img",{attrs:{src:"https://note.youdao.com/yws/public/resource/50a41f16bd4964e87185615287e32c81/xmlnote/C7B57AF335AE40CDB76F6926F0DBDAF2/31849",alt:"image"}})]),t._v(" "),l("ul",[l("li",[t._v("方法演示如下")])]),t._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[t._v('    public class FileMethodDemo3 {\n    \tpublic static void main(String[] args) {\n    \t\tFile dir = new File("e:\\\\java_code");\n    \t\t//获取的是目录下的当前的文件以及文件夹的名称。\n    \t\tString[] names = dir.list();\n    \t\tfor(String name : names){\n    \t\t\tSystem.out.println(name);\n    \t\t}\n    \t\t//获取目录下当前文件以及文件对象，只要拿到了文件对象，那么就可以获取其中想要的信息\n    \t\tFile[] files = dir.listFiles();\n    \t\tfor(File file : files){\n    \t\t\tSystem.out.println(file);\n    \t\t}\n    \t}\n    }\n\n')])])]),l("p",[l("strong",[t._v("注意：在获取指定目录下的文件或者文件夹时必须满足下面两个条件")])]),t._v(" "),l("ul",[l("li",[t._v("1.指定的目录必须是存在的")]),t._v(" "),l("li",[t._v("2.指定的必须是目录。否则容易引发返回数组为null，出现NullPointerException")])]),t._v(" "),l("hr"),t._v(" "),l("h4",{attrs:{id:"文件过滤器"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#文件过滤器","aria-hidden":"true"}},[t._v("#")]),t._v(" 文件过滤器")]),t._v(" "),l("blockquote",[l("p",[t._v("通过listFiles()方法，我们可以获取到一个目录下的所有文件和文件夹，但能不能对其进行过滤呢？比如我们只想要一个目录下的指定扩展名的文件，或者包含某些关键字的文件夹呢")])]),t._v(" "),l("blockquote",[l("p",[t._v("我们是可以先把一个目录下的所有文件和文件夹获取到，并遍历当前获取到所有内容，遍历过程中在进行筛选，但是这个动作有点麻烦，Java给我们提供相应的功能来解决这个问题")])]),t._v(" "),l("blockquote",[l("p",[t._v("查阅File类的API，在查阅时发现File类中重载的listFiles方法，并且接受指定的过滤器")])]),t._v(" "),l("p",[l("img",{attrs:{src:"https://note.youdao.com/yws/public/resource/50a41f16bd4964e87185615287e32c81/xmlnote/20B873CC8F7A4D559A0CE9DECEBDAA08/31851",alt:"image"}})]),t._v(" "),l("p",[l("img",{attrs:{src:"https://note.youdao.com/yws/public/resource/50a41f16bd4964e87185615287e32c81/xmlnote/D5253E38B7E14C92BE40E534C210406A/31853",alt:"image"}})]),t._v(" "),l("ul",[l("li",[t._v("测试类")])]),t._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[t._v('    public class FileDemo2 {\n    \tpublic static void main(String[] args) {\n    \t\t//获取扩展名为.java所有文件\n    \t\t//创建File对象\n    \t\tFile file = new File("E:\\\\test");\n    \t\t//获取指定扩展名的文件,由于要对所有文件进行扩展名筛选，因此调用方法需要传递过滤器\n    \t\tFile[] files = file.listFiles(new MyFileFilter());\n    \t\t//遍历获取到的所有符合条件的文件\n    \t\tfor (File f : files) {\n    \t\t\tSystem.out.println(f);\n    \t\t}\n    \t}\n    }\n\n')])])]),l("ul",[l("li",[t._v("自定类继承FilenameFilter过滤器接口")])]),t._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[t._v('    //定义类实现文件名称FilenameFilter过滤器\n    class MyFileFilter implements FilenameFilter{\n    \tpublic boolean accept(File dir, String name) {\n    \t\treturn name.endsWith(".java");\n    \t}\n    }\n\n')])])]),l("blockquote",[l("p",[t._v("在查阅API时，我们发现，在listFiles(FileFilter filter) 也可以接受一个FileFilter过滤器，它和我们讲的FilenameFilter有啥区别呢")])]),t._v(" "),l("p",[l("img",{attrs:{src:"https://note.youdao.com/yws/public/resource/50a41f16bd4964e87185615287e32c81/xmlnote/10F55A84B1A14E6AA499AE92006C9F76/31916",alt:"image"}})]),t._v(" "),l("p",[l("img",{attrs:{src:"https://note.youdao.com/yws/public/resource/50a41f16bd4964e87185615287e32c81/xmlnote/342C34EC671C4000991E686A5EB8AEB9/31918",alt:"image"}})]),t._v(" "),l("blockquote",[l("p",[t._v("FilenameFilter过滤器中的accept方法接受两个参数，一个当前文件或文件夹所在的路径，一个是当前文件或文件夹对象的名称")])]),t._v(" "),l("blockquote",[l("p",[t._v("FileFilter 过滤器中的accept方法接受一个参数，这个参数就当前文件或文件夹对象")])]),t._v(" "),l("blockquote",[l("p",[t._v("当我们需要"),l("strong",[t._v("过滤文件名称时就可以使用FilenameFilter这个过滤器")]),t._v("，当我们想对"),l("strong",[t._v("当前文件或文件夹进行过滤，就可以使用FileFilter")]),t._v(" ，比如需要当前目录下的所有文件夹，就可以使用FileFilter 过滤器")])]),t._v(" "),l("ul",[l("li",[t._v("测试类")])]),t._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[t._v('    public class FileDemo2 {\n    \tpublic static void main(String[] args) {\n    \t\t//获取扩展名为.java所有文件\n    \t\t//创建File对象\n    \t\tFile file = new File("E:\\\\test");\n    \t\t//获取指定目录下的文件夹\n    \t\tFile[] files = file.listFiles(new FileFileterByDir());\n    \t\t//遍历获取到的所有符合条件的文件\n    \t\tfor (File f : files) {\n    \t\t\tSystem.out.println(f);\n    \t\t}\n    \t}\n    }\n\n')])])]),l("ul",[l("li",[t._v("自定义类继承FileFilter过滤器接口")])]),t._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[t._v("    //文件过滤器\n    class FileFileterByDir implements FileFilter{\n    \tpublic boolean accept(File pathname) {\n    \t\treturn pathname.isDirectory();\n    \t}\n    }\n\n")])])]),l("hr"),t._v(" "),l("h3",{attrs:{id:"递归"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#递归","aria-hidden":"true"}},[t._v("#")]),t._v(" 递归")]),t._v(" "),l("h4",{attrs:{id:"递归的概述"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#递归的概述","aria-hidden":"true"}},[t._v("#")]),t._v(" 递归的概述")]),t._v(" "),l("blockquote",[l("p",[t._v("递归，指在当前方法内调用自己的这种现象")])]),t._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[t._v("    public void method(){\n    \tSystem.out.println(“递归的演示”);\n    \t//在当前方法内调用自己\n    \tmethod();\n    }\n\n")])])]),l("blockquote",[l("p",[t._v("递归分为两种，直接递归和间接递归\n直接递归称为方法自身调用自己。间接递归可以A方法调用B方法，B方法调用C方法，C方法调用A方法")])]),t._v(" "),l("ul",[l("li",[t._v("递归的代码演示，计算1-n之间的和，使用递归完成")])]),t._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[t._v("    public class DiGuiDemo {\n    \tpublic static void main(String[] args) {\n    \t\t//计算1~num的和，使用递归完成\n    \t\tint n = 5;\n    \t\tint sum = getSum(n);\n    \t\tSystem.out.println(sum);\n    \t\t\n    \t}\n    \tpublic static int getSum(int n) {\n    \t\tif(n == 1){\n    \t\t\treturn 1;\n    \t\t}\n    \t\treturn n + getSum(n-1);\n    \t}\n    }\n\n")])])]),l("ul",[l("li",[t._v("代码执行流程图解")])]),t._v(" "),l("p",[l("img",{attrs:{src:"https://note.youdao.com/yws/public/resource/50a41f16bd4964e87185615287e32c81/xmlnote/C0787F845C9A4C2EA4D6918C9EBE025F/31855",alt:"image"}})]),t._v(" "),l("p",[l("strong",[t._v("注意：递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出")])]),t._v(" "),l("hr"),t._v(" "),l("h4",{attrs:{id:"递归打印所有子目录中的文键路径"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#递归打印所有子目录中的文键路径","aria-hidden":"true"}},[t._v("#")]),t._v(" 递归打印所有子目录中的文键路径")]),t._v(" "),l("ul",[l("li",[l("p",[t._v("编写一个方法用来打印指定目录中的文件路径，并进行方法的调用")])]),t._v(" "),l("li",[l("p",[t._v("要求：若指定的目录有子目录，那么把子目录中的文件路径也打印出来")])]),t._v(" "),l("li",[l("p",[t._v("步骤:")]),t._v(" "),l("ul",[l("li",[t._v("指定要打印的目录File对象")]),t._v(" "),l("li",[t._v("调用getFileAll()方法\n"),l("ul",[l("li",[t._v("获取指定目录中的所有File对象")]),t._v(" "),l("li",[t._v("遍历得到每一个File对象")]),t._v(" "),l("li",[t._v("判断当前File 对象是否是目录\n"),l("ul",[l("li",[t._v("判断结果为true，说明为目录，通过递归，再次调用步骤2的getFileAll()方法")]),t._v(" "),l("li",[t._v("判断结果为false，说明是文件，打印文件的路径")])])])])])])]),t._v(" "),l("li",[l("p",[t._v("代码演示")])])]),t._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[t._v('    public class FileDemo2 {\n    \tpublic static void main(String[] args) {\n    \t\tFile file = new File("e:\\\\test");\n    \t\tgetFileAll(file);\n    \t}\n    \t//获取指定目录以及子目录中的所有的文件\n    \tpublic static void getFileAll(File file) {\n    \t\tFile[] files = file.listFiles();\n    \t\t//遍历当前目录下的所有文件和文件夹\n    \t\tfor (File f : files) {\n    \t\t\t//判断当前遍历到的是否为目录\n    \t\t\tif(f.isDirectory()){\n    \t\t\t\t//是目录，继续获取这个目录下的所有文件和文件夹\n    \t\t\t\tgetFileAll(f);\n    \t\t\t}else{\n    \t\t\t\t//不是目录，说明当前f就是文件，那么就打印出来\n    \t\t\t\tSystem.out.println(f);\n    \t\t\t}\n    \t\t}\n    \t}\n    }\n\n')])])]),l("hr"),t._v(" "),l("h4",{attrs:{id:"搜索指定目录中的-java文件-含子目录"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#搜索指定目录中的-java文件-含子目录","aria-hidden":"true"}},[t._v("#")]),t._v(" 搜索指定目录中的.java文件(含子目录)")]),t._v(" "),l("blockquote",[l("p",[t._v("需求：打印指定目录即所有子目录中的.java文件的文件路径")])]),t._v(" "),l("blockquote",[l("p",[t._v("要求：编写一个方法用来打印指定目录中的.java文件路径，并进行方法的调用")])]),t._v(" "),l("ul",[l("li",[t._v("若指定的目录有子目录，那么把子目录中的.java文件路径也打印出来")])]),t._v(" "),l("blockquote",[l("p",[t._v("步骤")])]),t._v(" "),l("ul",[l("li",[t._v("1.指定要打印的目录File对象")]),t._v(" "),l("li",[t._v("2.调用getFileAll()方法，传入要打印的目录File对象\n"),l("ul",[l("li",[t._v("通过FilenameFilter过滤器获取指定目录中的所有.java类型的File对象")]),t._v(" "),l("li",[t._v("遍历得到每一个File对象")]),t._v(" "),l("li",[t._v("判断当前File 对象是否是目录\n"),l("ul",[l("li",[t._v("判断结果为true，说明为目录，通过递归，再次调用步骤2的getFileAll()方法")]),t._v(" "),l("li",[t._v("判断结果为false，说明是文件，打印文件的路径")])])])])])]),t._v(" "),l("hr"),t._v(" "),l("h4",{attrs:{id:"实现代码步骤"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#实现代码步骤","aria-hidden":"true"}},[t._v("#")]),t._v(" 实现代码步骤")]),t._v(" "),l("ul",[l("li",[t._v("测试类")])]),t._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[t._v('    public class FileDemo4 {\n    \tpublic static void main(String[] args) {\n    \t\tFile file = new File("e:\\\\test");\n    \t\tgetFileAll(file);\n    \t}\n    \t//获取指定目录以及子目录中的所有的文件\n    \tpublic static void getFileAll(File file) {\n    \t\tFile[] files = file.listFiles(MyFileFilter());\n    \t\t//遍历当前目录下的所有文件和文件夹\n    \t\tfor (File f : files) {\n    \t\t\t//判断当前遍历到的是否为目录\n    \t\t\tif(f.isDirectory()){\n    \t\t\t\t//是目录，继续获取这个目录下的所有文件和文件夹\n    \t\t\t\tgetFileAll(f);\n    \t\t\t}else{\n    \t\t\t\t//不是目录，说明当前f就是文件，那么就打印出来\n    \t\t\t\tSystem.out.println(f);\n    \t\t\t}\n    \t\t}\n    \t}\n    }\n\n')])])]),l("ul",[l("li",[t._v("自定类实现FilenameFilter过滤器接口")])]),t._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[t._v('    //定义类实现文件名称FilenameFilter过滤器\n    class MyFileFilter implements FilenameFilter{\n    \tpublic boolean accept(File dir, String name) {\n    \t\treturn name.endsWith(".java");\n    \t}\n    }\n\n')])])]),l("hr"),t._v(" "),l("h3",{attrs:{id:"总结"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#总结","aria-hidden":"true"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),l("h4",{attrs:{id:"知识点总结"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#知识点总结","aria-hidden":"true"}},[t._v("#")]),t._v(" 知识点总结")]),t._v(" "),l("ul",[l("li",[l("p",[t._v("递归： 方法定义中调用方法本身的现象")]),t._v(" "),l("ul",[l("li",[t._v("直接递归")])]),t._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[t._v("    public void methodA(){\n\t\tmethodA();\n\t\n    }\n")])])]),l("ul",[l("li",[t._v("间接递归")])]),t._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[t._v("    public void metohdB(){\n\t\tmethodC();\n\t}\n\tpublic void methodC(){\n\t\tmethodB();\n\t}\n\n")])])]),l("ul",[l("li",[t._v("递归注意实现\n"),l("ul",[l("li",[t._v("要有出口，否则就是死递归")]),t._v(" "),l("li",[t._v("次数不能太多，否则就内存溢出")])])])])]),t._v(" "),l("li",[l("p",[t._v("File: 文件和目录路径名的抽象表示形式")]),t._v(" "),l("ul",[l("li",[l("p",[t._v("构造方法:")]),t._v(" "),l("ul",[l("li",[t._v("public File(String pathname) 通过给定的文件或文件夹的路径，来创建对应的File对象")]),t._v(" "),l("li",[t._v("public File(String parent, String child) 通过给定的父文件夹路径，与给定的文件名称或目录名称来创建对应的File对象")]),t._v(" "),l("li",[t._v("public File(File parent,  String child)通过给定的File对象的目录路径，与给定的文件夹名称或文件名称来创建对应的File对象")])])]),t._v(" "),l("li",[l("p",[t._v("路径的分类")]),t._v(" "),l("ul",[l("li",[t._v("绝对路径, 带盘盘符")])]),t._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[t._v("    E:\\\\work\\\\a.txt\n")])])]),l("ul",[l("li",[t._v("相对路径， 不带盘符")])]),t._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[t._v("    work\\\\a.txt\n")])])]),l("ul",[l("li",[t._v("注意： 当指定一个文件路径的时候，如果采用的是相对路径，默认的目录为 项目的根目录")])])]),t._v(" "),l("li",[l("p",[t._v("方法")]),t._v(" "),l("ul",[l("li",[t._v("public boolean createNewFile()创建文件\n"),l("ul",[l("li",[t._v("返回值为true， 说明创建文件成功")]),t._v(" "),l("li",[t._v("返回值为false，说明文件已存在，创建文件失败")])])]),t._v(" "),l("li",[t._v("public boolean mkdir() 创建单层文件夹\n"),l("ul",[l("li",[t._v("创建文件夹成功，返回 true")]),t._v(" "),l("li",[t._v("创建文件夹失败，返回 false")])])]),t._v(" "),l("li",[t._v("public boolean mkdirs() 创建多层文件夹")]),t._v(" "),l("li",[t._v("public boolean delete()\n"),l("ul",[l("li",[t._v("删除此抽象路径名表示的文件或目录")]),t._v(" "),l("li",[t._v("如果此路径名表示一个目录，则该目录必须为空才能删除")])])]),t._v(" "),l("li",[t._v("public boolean isDirectory() 判断是否为文件夹")]),t._v(" "),l("li",[t._v("public boolean isFile() 判断是否为文件")]),t._v(" "),l("li",[t._v("public boolean exists() 判断File对象对应的文件或文件夹是否存在")]),t._v(" "),l("li",[t._v("public String getAbsolutePath() 获取当前File的绝对路径")]),t._v(" "),l("li",[t._v("public String getName() 获取当前File对象的文件或文件夹名称")]),t._v(" "),l("li",[t._v("public long length() 获取当前File对象的文件或文件夹的大小（字节）")]),t._v(" "),l("li",[t._v("public File[] listFiles() 获取File所代表目录中所有文件或文件夹的绝对路径")])])])])])])])}],!1,null,null,null);e.default=a.exports}}]);